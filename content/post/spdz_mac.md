---
layout:     post
title:      "SPDZ MAC 恶意模型原理"
date:       2026-01-11
author:     "Invisibook Lab"
tags:       ["MPC", "SPDZ", "MAC", "密码学"]
categories: ["Tech"]
---

## 如何理解 SPDZ 中信息论 MAC 如何防止篡改

安全多方计算（MPC）允许多个参与方在不暴露各自私有数据的前提下，共同计算一个函数的值。SPDZ 是一种被广泛使用的 MPC 协议，它不仅保护隐私，还能抵抗恶意行为者，即使某些参与方试图作弊或篡改数据，协议也能检测出来并保证结果正确性。其关键技术之一就是**信息论安全的消息认证码（MAC）机制**。([登链社区][1])

---

### 什么是信息论 MAC 在 SPDZ 中的角色？

在 SPDZ 协议中，每个秘密共享的数值不仅仅是一个“份额”，还配有一个**认证标签（MAC 标签）**。这个标签是由一个对所有参与方共享但没有任何单个参与方知道的**全局密钥**和该数值组合生成的。换句话说：

* 每个秘密共享的值 (v) 都有一个对应的 MAC 标签。
* MAC 标签是用一个全局密钥对 (v) “签名”的结果，但这个签名是秘密共享形式保存的。
* 所有参与方各自持有一部分共享值和对应的 MAC 份额。([Medium][2])

因为这个全局密钥对所有参与方都是隐藏的（通过秘密共享产生并且不在任何一方手里单独存在），任何一方无法单独伪造一个有效的 MAC 标签。这种 MAC 不依赖计算假设（比如大数分解困难），即使对手有无限计算资源，只要没有整个密钥，就无法伪造合法标签——因此称为**信息论安全**。

---

### MAC 如何帮助防止篡改？

#### 1. 每个数值都有认证标签

在 SPDZ 中，参与计算的每一个共享值都有：

* 一个秘密分享的值；
* 与之对应的 MAC 认证标签。

这个标签证明该值确实是由协议合法产生的，而不是参与者任意伪造的。([Medium][2])

#### 2. 在线阶段的运算保持 MAC 一致性

在协议的在线计算阶段，各种加法、乘法等运算不仅在共享值上执行，也在相应的 MAC 标签上做同样的操作。协议设计保证了：

* 如果某个参与方试图篡改一个中间秘密值，那它**必须同时篡改对应的 MAC 标签**；
* 但因为 MAC 标签是基于全局密钥生成的，而这个密钥每个参与者只有部分共享且不能重构，参与者无法自己构造有效的新的 MAC 标签。([Medium][2])

换句话说，在计算过程中，MAC 标签被“跟随”秘密共享的值一起传播，任何未经授权的变动都会导致标签关系不一致。

#### 3. 揭示最终值时的 MAC 检查

当协议需要重新构建某个秘密值（比如输出最终结果）时，参与方会公开分享他们手中的值份额和 MAC 标签份额。协议通过下面两步验证一致性：

* **组合所有的值份额和 MAC 标签份额**，得到完整的值 (v)、完整的 MAC 标签 (m)、以及完整的全局密钥份额 (k)；
* **验证是否满足** (m = \text{MAC}(k, v)) 这类关系（即标签确实正确地对应该值和密钥）。

如果任何一处被篡改（无论是数值还是标签），整个组合检验就会失败。因此，协议可以检测出哪怕是单个参与方试图输出错误结果的行为。([Medium][2])

---

### 为什么这种机制足够强大？

这种基于信息论的 MAC 机制有两个核心优势：

* **不依赖对手计算能力**：攻击者即使拥有无限计算资源，如果没有完整密钥份额，也无法构造一个匹配的 MAC，这比基于大数分解等硬问题的安全性更强。
* **防篡改覆盖整个计算过程**：不只是最后的输出，每一次运算都伴随标签维护和检查，因此作弊会在输出揭示前被检测到。([SANDS][3])

由于这些特点，SPDZ 的信息论 MAC 是实现 **恶意安全（malicious security）** 的基石之一。这意味着协议不只防止参与者偷窥数据，还能确保参与者不能通过故意偏离规定的操作来控制计算结果。([登链社区][1])

---

## 示例

目标：

> **两个人 A 和 B，在谁都不可信的情况下，
> 私下比较两个数 x 和 y 的大小，
> 并且谁也无法偷偷改结果。**

---

### 第一阶段：准备阶段（还没开始算 x ≥ y）

这一阶段的目标只有一件事：

> **制造一个“所有人都要服从，但没人知道内容”的隐藏规则。**

这个规则，就是后面你看到的“影子规则”。

---

#### 第 1 步：每个人各自选一个秘密数

A 做什么？

* A 自己偷偷选一个随机数
  比如：

  > A 选了 3
* **不告诉任何人**

B 做什么？

* B 自己偷偷选一个随机数
  比如：

  > B 选了 4
* **不告诉任何人**

---

#### 第 2 步：约定一个“合成规则”

大家事先说好：

> **真正的“影子规则数字” =
> A 的数 + B 的数**

于是，在逻辑上：

* 这个规则数字等于：
  3 + 4 = 7

⚠️ 注意一个非常关键的事实：

* A 不知道 4
* B 不知道 3
* **所以 A 和 B 都不知道 7**
* 但 **7 确实存在**

---

#### 第 3 步：这个“7”永远不会被说出口

* 没有人打印它
* 没有人存它
* 没有人能“泄露”它

它只以一种形式存在：

> **A 手里有“3 的影响”，
> B 手里有“4 的影响”。**

这一步结束后，系统里已经有了一个事实：

> **以后所有数，都必须服从这个“看不见的 7 的规则”。**

---

### 第二阶段：把输入数字“拆开并绑定规则”

现在才轮到真正的数据。

---

#### 第 4 步：把 x 和 y 拆成两份

假设真实输入是：

* x = 3（A 的秘密）
* y = 5（B 的秘密）

 -- 拆 x --

* A 拿：1
* B 拿：2
  （1 + 2 = 3）

 -- 拆 y --

* A 拿：2
* B 拿：3
  （2 + 3 = 5）

此时：

* A 看不到完整的 x 或 y
* B 也看不到

---

#### 第 5 步：给每个“拆开的数”生成影子

规则是：

> **影子 = 这个数 × 那个看不见的 7**

 **但问题是：没人知道 7，怎么算？**

答案是：

* A 用自己的那份（3）
* B 用自己的那份（4）
* 各自算“我这一份造成的影子”

---

### 例子：给 x = 3 生成影子

x 被拆成：

* A：1
* B：2

影子拆法是：

* A 算：1 × 3 = 3
* B 算：2 × 4 = 8

影子合起来是：

* 3 + 8 = 11
  （这正好等于 3 × 7）

⚠️ 没有人算过“3 × 7”
但结果已经被“拼”出来了。

---

#### 到这里，每个数都变成了什么？

**每个数都变成了一对东西：**

* 一份“数字碎片”
* 一份“影子碎片”

  -- A 手里有 --

* x 的一小份
* x 的影子一小份
* y 的一小份
* y 的影子一小份

  -- B 也一样 --

---

# 第三阶段：开始真正计算（以 x ≥ y 为例）

现在开始算：

> **x ≥ y 吗？**

---

## 第 6 步：先算差值 z = x − y

这是比较大小的第一步。

- A 在本地算：

* 自己的 z 碎片 =
  x 的碎片 − y 的碎片

- B 也在本地算

两个人**不通信**，只是本地减法。

---

#### 第 7 步：影子也跟着一起算

规则是：

> **你怎么改数字，就必须同步改影子**

所以：

* A 用自己的影子碎片做减法
* B 也一样

这一步非常重要：

> **影子永远和数字一起走。**

---

### 第四阶段：假设 A 想作弊（关键场景）

假设真实情况是：

* x = 3
* y = 5
* z = −2（应该是“x < y”）

A 不想接受这个结果。

---

#### 第 8 步：A 试图作弊

A 想：

> “我偷偷把 z 的那一份改大一点，
> 让最后结果变成正数。”

于是：

* A 改了 **数字碎片**
* 但问题来了：

---

#### 第 9 步：A 完全不知道影子该怎么改

A 面临一个不可解决的问题：

* 他不知道“规则数字是 7”
* 他不知道：

  > “如果我把数字改成这样，
  > 影子应该是多少？”

他只能：

* 不改影子 → 一定被发现
* 乱猜影子 → 几乎一定被发现

---

### 第五阶段：最后的统一检查（MAC check）

这一步是 **整套系统的“审计时刻”**。

---

#### 第 10 步：把所有碎片合起来检查

系统要求做一件事：

> **把所有人的数字碎片加起来，
> 再把所有人的影子碎片加起来，
> 看它们是不是还服从那条“7 的规则”。**

---

 如果所有人都诚实：

* 数字 × 7 = 影子
* 完全对得上
* 比较结果被接受

---

 如果 A 作恶过哪怕一次：

* 数字和影子一定对不上
* 不存在“侥幸成功”
* 协议立刻终止

---

### 第六阶段：为什么 A 永远赢不了？

因为他被三件事同时卡死：

1. **他看不到完整数字**
2. **他不知道规则数字**
3. **影子必须和数字同步变化**


## 小结

在 SPDZ 协议中，信息论安全的 MAC 是一种针对计算完整性的保护机制。它通过对每一个共享值附加认证标签：

* 让恶意参与者无法单独伪造有效标签；
* 在每次操作中维护标签与值的一致性；
* 在结果公开时检查标签与值是否匹配；

从而有效阻止了任何未经授权的篡改，从协议内部保证了正确性与安全性。
