---
layout:     post
title:      "SPDZ MAC 恶意模型原理"
date:       2026-01-11
author:     "Invisibook Lab"
tags:       ["MPC", "SPDZ", "MAC", "密码学"]
categories: ["Tech"]
---

安全多方计算（MPC）允许多个参与方在不暴露各自私有数据的前提下，共同计算一个函数的值。SPDZ 是一种被广泛使用的 MPC 协议，它不仅保护隐私，还能抵抗恶意行为者，即使某些参与方试图作弊或篡改数据，协议也能检测出来并保证结果正确性。其关键技术之一就是**信息论安全的消息认证码（MAC）机制**。

---

### 什么是信息论 MAC 在 SPDZ 中的角色？

在 SPDZ 协议中，每个秘密共享的数值不仅仅是一个“份额”，还配有一个**认证标签（MAC 标签）**。这个标签是由一个对所有参与方共享但没有任何单个参与方知道的**全局密钥**和该数值组合生成的。换句话说：

* 每个秘密共享的值 (v) 都有一个对应的 MAC 标签。
* MAC 标签是用一个全局密钥对 (v) “签名”的结果，但这个签名是秘密共享形式保存的。
* 所有参与方各自持有一部分共享值和对应的 MAC 份额。

因为这个全局密钥对所有参与方都是隐藏的（通过秘密共享产生并且不在任何一方手里单独存在），任何一方无法单独伪造一个有效的 MAC 标签。这种 MAC 不依赖计算假设（比如大数分解困难），即使对手有无限计算资源，只要没有整个密钥，就无法伪造合法标签——因此称为**信息论安全**。

---

### MAC 如何帮助防止篡改？

#### 1. 每个数值都有认证标签

在 SPDZ 中，参与计算的每一个共享值都有：

* 一个秘密分享的值；
* 与之对应的 MAC 认证标签。

这个标签证明该值确实是由协议合法产生的，而不是参与者任意伪造的。

#### 2. 在线阶段的运算保持 MAC 一致性

在协议的在线计算阶段，各种加法、乘法等运算不仅在共享值上执行，也在相应的 MAC 标签上做同样的操作。协议设计保证了：

* 如果某个参与方试图篡改一个中间秘密值，那它**必须同时篡改对应的 MAC 标签**；
* 但因为 MAC 标签是基于全局密钥生成的，而这个密钥每个参与者只有部分共享且不能重构，参与者无法自己构造有效的新的 MAC 标签。

换句话说，在计算过程中，MAC 标签被“跟随”秘密共享的值一起传播，任何未经授权的变动都会导致标签关系不一致。

#### 3. 揭示最终值时的 MAC 检查

当协议需要重新构建某个秘密值（比如输出最终结果）时，参与方会公开分享他们手中的值份额和 MAC 标签份额。协议通过下面两步验证一致性：

* **组合所有的值份额和 MAC 标签份额**，得到完整的值 (v)、完整的 MAC 标签 (m)、以及完整的全局密钥份额 (k)；
* **验证是否满足** (m = text{MAC}(k, v)) 这类关系（即标签确实正确地对应该值和密钥）。

如果任何一处被篡改（无论是数值还是标签），整个组合检验就会失败。因此，协议可以检测出哪怕是单个参与方试图输出错误结果的行为。

---

### 为什么这种机制足够强大？

这种基于信息论的 MAC 机制有两个核心优势：

* **不依赖对手计算能力**：攻击者即使拥有无限计算资源，如果没有完整密钥份额，也无法构造一个匹配的 MAC，这比基于大数分解等硬问题的安全性更强。
* **防篡改覆盖整个计算过程**：不只是最后的输出，每一次运算都伴随标签维护和检查，因此作弊会在输出揭示前被检测到。

由于这些特点，SPDZ 的信息论 MAC 是实现 **恶意安全（malicious security）** 的基石之一。这意味着协议不只防止参与者偷窥数据，还能确保参与者不能通过故意偏离规定的操作来控制计算结果。

---

## 示例

有两个人：

* A
* B

目标：
**在不信任任何人的情况下，保证没人能篡改中间结果。**

---

## 第一阶段：生成一个“没人知道的规则数 α”

### 第 1 步：各自选一个秘密数

* A 选：αₐ = 3
* B 选：αᵦ = 4

### 第 2 步：逻辑上定义

> **真正的 α = 3 + 4 = 7**

重要事实：

* A 不知道 4
* B 不知道 3
* **没人知道 α = 7**

但它**确实存在**。

---

## 第二阶段：秘密共享一个普通数字 x

假设：

* x = 3

### 拆成两份：

* A 拿：xₐ = 1
* B 拿：xᵦ = 2

1 + 2 = 3 ✔

---

## 第三阶段：生成“影子”

### 关键原则（请牢牢记住这一句）：

> **影子不是“某个人算出来的”，
> 而是“被定义出来的一个一致性约束”。**

真实规则是：

> **影子 = α × x**

在逻辑上：

* α = 7
* x = 3
* 所以影子 = 21

⚠️ 注意：

* **没有任何人真的“算”过 7 × 3**
* 21 只是一个“必须成立的事实”

---

### 那影子怎么拆给 A 和 B？

系统只做一件事：

> **随便拆，只要两份加起来是 21**

例如：

* A 拿影子的一份：3 x 3 = 9
* B 拿影子的一份：3 x 4 = 12

9 + 12 = 21 ✔

---

## 现在，每个人手里有什么？

### A 手里：

* 数字的一份：1
* 影子的一份：9

### B 手里：

* 数字的一份：2
* 影子的一份：12

这时，全局满足一个事实：

> **（A 的影子 + B 的影子）
> = α ×（A 的数字 + B 的数字）**

而且：

* A 不知道 α
* B 不知道 α

---

## 第四阶段：开始计算（例如做减法、比较）

假设要算：

> z = x − y

规则是：

* 数字怎么变
* 影子就**必须跟着同样的方式变**

比如：

* A：

  * zₐ = xₐ − yₐ
  * 影子ₐ = 影子ₓₐ − 影子ᵧₐ
* B 同理

这一步**不需要知道 α**。

---

## 第五阶段：A 尝试作弊（关键）

A 想：

> “我偷偷把 zₐ 改大一点。”

于是他改了：

* 数字份额：✔ 他能改
* 影子份额：❌ 他不知道该改成多少

因为：

> **影子必须仍然满足：
> 总影子 = α × 总数字**

但 α 对 A 是未知的。

---

## 第六阶段：最终检查（MAC check）

系统做的事情只有一句话：

> **把所有人的数字加起来，
> 把所有人的影子加起来，
> 看是否仍然满足
> ‘影子 = α × 数字’**

如果 A 作恶过：

* 这个等式一定不成立
* 不存在“蒙对”的策略（概率极低）

---



## 小结

在 SPDZ 协议中，信息论安全的 MAC 是一种针对计算完整性的保护机制。它通过对每一个共享值附加认证标签：

* 让恶意参与者无法单独伪造有效标签；
* 在每次操作中维护标签与值的一致性；
* 在结果公开时检查标签与值是否匹配；

从而有效阻止了任何未经授权的篡改，从协议内部保证了正确性与安全性。
